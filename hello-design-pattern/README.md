# 设计模式



## 一、策略模式（Strategy）

> 定义一系列算法，分别封装起来，并且使它们能够在运行时相互替换。

JDK中采用策略模式：

- 在构建ThreadPoolExecutor时可以传入拒绝执行策略（RejectedExecutionHandler）

P37

**继承 VS 组合**

- 继承（IS-A）
- 组合（HAS-A）



**设计原则**

- 抽取需要变化的部分
- 面向接口，而不是面向实现
- 多用组合，少用继承

P61



## 二、观察者模式（Observer）

> 定义了对象之间一对多的关系，当一个对象的状态发生改变时，它的所有依赖者都能收到通知并更新

观察者模式在JDK中使用最多的模式之一

P73

**设计原则**

- 封装变化
- 面向接口，而不是实现
- 多用组合，少用继承
- 松耦合

P114



## 三、装饰者模式（Decorate）

> 动态地将责任添加到对象上

JDK中的 `java.io` 使用了装饰者模式（FileInputStream、BufferedInputStream……）

P115

**设计原则**

- 封装变化
- 面向接口，而不是实现
- 多用组合，少用继承
- 松耦合
- 开闭原则（对扩展开放，对修改关闭）

P144



## 四、简单工厂（Simple Factory）

> 定义一个创建对象的简单工厂类，通过工厂类创建不同的具体对象

简单工厂其实就是把创建具体对象的代码封装到单独的一个类中，在其他需要创建这些对象的地方就不用重复写这些代码。

我们把这样一个创建具体对象的类叫做简单工厂

**优点**

- 提高代码的可复用性

**缺点**

- 不能满足“变化”，当需要创建新的具体的对象时，需要对其简单工厂类进行修改，不符合开闭原则



## 五、工厂方法模式

> 定义一个创建对象的接口，由子类决定具体实例化的类是哪一个。工厂方法将对象的实例化推迟到子类。

P145

**设计原则**

- 依赖倒置原则（依赖抽象，而不是依赖具体的类）
